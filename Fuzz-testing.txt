Fuzz-тестирование

Тестируемое приложение - дипломный проект автопарка на ASP.NET. Для тестирования я выбрал только его бэкенд и тестировал инструмент API-фаззинга от Microsoft - restler-fuzzer (https://github.com/microsoft/restler-fuzzer). В проекте порядка 2000 строк кода с учётом только "бизнес-логики", т.е. без Razor Pages и генераторов данных для базы данных, но с API-фронтендом. 

Перед использованием этого инструмента я перебрал порядка 5 других инструментов, но из-за специфики проекта и ряда проблем (о них позже) я решил остановиться именно на restler-fuzzer. 

Сначала для проекта потребовалось настроить API-документацию в Swagger. Сделав это, я скачал json-документ и по нему инструмент протестировал все эндпоинты. 

Программа работала целых 8 (!) дней и предоставила следующие результаты:
1. Покрытие - 17/17, 100%. 
2. InvalidValuesChecker - при отправке неправильных данных на 8 эндпоинтов сервер возвращает HTTP код 500. Эндпоинты с этим кодом:
2.1. Получение водителей и автомобилей с негативным оффсетом. 
2.2. Создание нового, обновление и удаление водителя, прикреплённого к предприятию, доступ к которому пользователь не имеет. 
2.3. Рендер карты для маршрута автомобиля с выбранным айди. Отрицательный айди или индекс вне формата. 
2.4. Создание нового автомобиля, неправильный формат строки DateTime. 
2.5. Обновление автомобиля конфликтует с внешним ключом с таблицей водителей в базе данных.
3. PayloadBodyChecker - в теле запроса занесены неправильные данные с кодом ответа 500. Эндпоинты:
3.1. Создание, обновление водителя, прикреплённого к предприятию, доступ к которому пользователь не имеет или без добавления токена. 
3.2. Рендер пути автомобиля с неправильным телом запроса.

Всего было обнаружено 16 уникальных ошибок (которые всё равно частично повторяли друг друга). Исправить их будет не сложно - все ошибки, кроме одной, можно исправить с помощью дополнительных проверок (и возврата нужных 4** HTTP-кодов там, где эти проверки есть, вместо 500). 

Причина всего одной ошибки (связанной с SQL) беспокоит меня, но, скорее всего, её причина в том, что я не проверяю существования водителя с указанным айди перед манипуляцией с даными. 

О проблемах, с которыми я столкнуля при тестировании. Проблем было много, несколько дней подряд я только пытался выбрать подходящий инструмент и запустить его. 

afl у меня не заработал в связи с архитектурой моей рабочей системы, на которой я работаю. Этот инструмент не работает на ARM-архитектуре. Можно было бы запустить его в докере, но я не стал. Для лучшего понимания технологии изучил теоретические данные, но на будущее нужно изучить ещё больше. Как минимум потому, что образ контейнера использует afl++. Я не знаю, чем отличается этот инструмет от его базовой версии, поэтому я решил не использовать его для текущего задания. 

Далее я попробовал ClusterFuzz, но при запуске ничего не работало.

То же и со schemathesis. 

Попробовал плагин afl для C#, но оказалось, что это только высокоуровневый интерфейс для того же инструмента afl, поэтому здесь также не пошло. 

Далее я начал искать специализированные инструменты для api-fuzz тестирования. Тогда я обнаружил инструмент Restler, но и тут сразу всё не заработало. Во-первых, этот инструмент от майкрософт работает на F# и у меня сперва появились проблемы с версией .NET Runtime: проект работает на версии 6.0, а у меня была установлена версия 8.0. Почему-то сперва такая конфигурация не сработала, но когда я снёс версию, скачанную из homebrew, и установил новую версию 8.0 с официального сайта. 

Однако тест не заработал - эндпоинты просто не отправлялись. Решение оказалось простым: я запустил приложение без HTTPS-шифровки, и всё заработало. 

Впредь разработку есть смысл вести с докера, как я понял после нескольких дней неудачных попыток запустить различные инструменты. Также нужно попробовать всегда искать как можно более подробную документацию на все инструменты, которые я использую. С другой стороны, все вышеперечисленные инструменты fuzz-тестирования задокументированы не в полной мере. Это иструменты продвинутых разработчиков, и многие очевидные вещи (как, например, необходимость в публичной подписи сертификатов для веб-приложений) не нужно им напоминать. 
Такой тип тестирования для меня оказался в новинку: когда тестирование твоего приложения занимает практически неделю, проделанная работа действительно ощущается масштабной - это мотивирует!






